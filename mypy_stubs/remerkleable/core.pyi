from remerkleable.tree import Gindex as Gindex, Node as Node, Root as Root, RootNode as RootNode, concat_gindices as concat_gindices, zero_node as zero_node
from typing import Any, BinaryIO, Callable, Iterable, List as PyList, Optional, Tuple, Type, TypeVar, Union, _ProtocolMeta

OFFSET_BYTE_LENGTH: int
V = TypeVar('V', bound='View')

class ViewMeta(_ProtocolMeta):
    def __truediv__(self, other: Any) -> Path: ...
ObjType = Union[dict, list, tuple, str, int, bool, None]

class ObjParseException(Exception): ...

class Path:
    anchor: Type[View]
    path: PyList[Tuple[Any, Type[View]]]
    def __init__(self, anchor: Type[View], path: Optional[PyList[Tuple[Any, Type[View]]]]=...) -> Any: ...
    @staticmethod
    def from_raw_path(anchor: Type[View], path: PyList[Any]) -> Path: ...
    def __truediv__(self, other: Any) -> Path: ...
    def gindex(self, view: Optional[View]=...) -> Gindex: ...
    def navigate_type(self) -> Type[View]: ...
    def navigate_view(self, v: View) -> View: ...
HV = TypeVar('HV', bound='View')
ViewHook = Callable[[HV], None]

class View(metaclass=ViewMeta):
    @classmethod
    def coerce_view(cls: Type[V], v: Any) -> V: ...
    @classmethod
    def default_node(cls: Any) -> Node: ...
    @classmethod
    def view_from_backing(cls: Type[V], node: Node, hook: Optional[ViewHook[V]]=...) -> V: ...
    @classmethod
    def is_fixed_byte_length(cls: Any) -> bool: ...
    @classmethod
    def min_byte_length(cls: Any) -> int: ...
    @classmethod
    def max_byte_length(cls: Any) -> int: ...
    @classmethod
    def decode_bytes(cls: Type[V], bytez: bytes) -> V: ...
    @classmethod
    def deserialize(cls: Type[V], stream: BinaryIO, scope: int) -> V: ...
    @classmethod
    def from_obj(cls: Type[V], obj: ObjType) -> V: ...
    @classmethod
    def type_repr(cls: Any) -> str: ...
    @classmethod
    def navigate_type(cls: Any, key: Any) -> Type[View]: ...
    @classmethod
    def key_to_static_gindex(cls: Any, key: Any) -> Gindex: ...
    @classmethod
    def default(cls: Type[V], hook: Optional[ViewHook[V]]) -> V: ...
    def get_backing(self) -> Node: ...
    def set_backing(self, value: Any) -> None: ...
    def copy(self) -> V: ...
    @classmethod
    def type_byte_length(cls: Any) -> int: ...
    def value_byte_length(self) -> int: ...
    def __bytes__(self): ...
    def encode_bytes(self) -> bytes: ...
    def serialize(self, stream: BinaryIO) -> int: ...
    def to_obj(self) -> ObjType: ...
    def navigate_view(self, key: Any) -> View: ...
    def key_to_dynamic_gindex(self, key: Any) -> Gindex: ...
    def hash_tree_root(self) -> Root: ...
    def __eq__(self, other: Any) -> Any: ...
    def __hash__(self) -> Any: ...

class FixedByteLengthViewHelper(View):
    @classmethod
    def is_fixed_byte_length(cls: Any) -> bool: ...
    @classmethod
    def min_byte_length(cls: Any) -> int: ...
    @classmethod
    def max_byte_length(cls: Any) -> int: ...
    @classmethod
    def deserialize(cls: Type[V], stream: BinaryIO, scope: int) -> V: ...
    def value_byte_length(self) -> int: ...
BackedV = TypeVar('BackedV', bound='BackedView')

class BackedView(View):
    @classmethod
    def view_from_backing(cls: Type[BackedV], node: Node, hook: Optional[ViewHook]=...) -> BackedV: ...
    def __new__(cls: Any, backing: Optional[Node]=..., hook: Optional[ViewHook]=..., **kwargs: Any) -> Any: ...
    def get_backing(self) -> Node: ...
    def set_backing(self, value: Any) -> None: ...
BV = TypeVar('BV', bound='BasicView')

class BasicView(FixedByteLengthViewHelper):
    @classmethod
    def default_node(cls: Any) -> Node: ...
    @classmethod
    def view_from_backing(cls: Type[BV], node: Node, hook: Optional[ViewHook[BV]]=...) -> BV: ...
    @classmethod
    def basic_view_from_backing(cls: Type[BV], node: Node, i: int) -> BV: ...
    @classmethod
    def pack_views(cls: Type[BV], views: PyList[BV]) -> PyList[Node]: ...
    def copy(self) -> V: ...
    def backing_from_base(self, base: Node, i: int) -> Node: ...
    def get_backing(self) -> Node: ...
    def set_backing(self, value: Any) -> None: ...

def grouper(items: Iterable, n: int, fillvalue: Any=...) -> Iterable[Tuple]: ...
def pack_ints_to_chunks(items: Iterable[int], items_per_chunk: int) -> PyList[Node]: ...
def bits_to_byte_int(byte: Tuple[bool, bool, bool, bool, bool, bool, bool, bool]) -> int: ...
def byte_int_to_byte(b: int) -> bytes: ...
def pack_bits_to_chunks(items: Iterable[bool]) -> PyList[Node]: ...
def pack_byte_ints_to_chunks(items: Iterable[int]) -> PyList[Node]: ...
def pack_bytes_to_chunks(bytez: bytes) -> PyList[Node]: ...
